---
title: "Analysing hydrogen-deuterium exchange experiments on PINK1 and a nanobody"
author:
- name: Oliver M. Crook
package: hdxstats
output:
  BiocStyle::html_document:
    toc_float: yes
abstract: "This vignette describes how to analyse a mass-spectrometry based  hydrogen
  deuterium exchange experiment, in particular we focus on empirical Bayes functional
  models and visualisations. Here, we provide a case-study on the analysis
  of an experiment on PINK1 \n"
vignette: |
  %\VignetteIndexEntry{Analysing a PINK1 + nanobody experiment}
  %\VignetteEngine{knitr::rmarkdown}
  %%\VignetteKeywords{Mass Spectrometry, MS, MSMS, Proteomics, Metabolomics, Infrastructure, Quantitative} %\VignetteEncoding{UTF-8}
---

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
knitr::opts_chunk$set(dpi=300)
```

```{r env, message = FALSE, warning = FALSE, echo = FALSE}
library("hdxstats")
library("dplyr")
library("ggplot2")
library("RColorBrewer")
library("tidyr")
library("pheatmap")
library("scales")
library("viridis")
library("patchwork")
library("Biostrings")

```

# A well-defined HDX-MS experiment

This vignette describeds how to analyse time-resolved differential HDX-MS
experiments. The key elements are at least two conditions i.e. apo + antibody,
apo + small molecule or protein closed + protien open, etc. The experiment can
be replicated, though if there are sufficient time points analysed (>=3) then
occasionally signficant results can be obtained. The data provided should be
centroid-centric data. This package does not yet support analysis straight
from raw spectra. Typically this will be provided as a .csv from tools such as
dynamiX or HDExaminer.

# PINK1 in complex with its substrate ubiquitin

PINK1 phosphorylates both ubiquitin and the ubiquitin-like domain of Parkin on 
structurally protected Ser65 residues, triggering mitophagy (see Schubert
et al 2017 Nature.) Here, we examine an experiment where phosphorylated PINK1
phPINK1 binds to Ub-TVLN (ubiqutin with point mutations T66V/L67N, which is 
stablised in complexation with a nanobody Nb696. 

# Data for phPINK1 and in complex with Ub-TVLN and Nb696 

We will begin with a structural variant experiment in which MHP and a structural
variant were mixed in different proportions. HDX-MS was performed on these samples
and we expect to see reproducible but subtle differences. We first load the data
from the package and it is .csv format.

```{r,}
phPINKpath <- system.file("extdata", "PINKdataphPINK1.csv", package = "hdxstats")
phPINKcomplexpath <- system.file("extdata", "PINKdataphPINK1ubNB696.csv", package = "hdxstats")
```

We can now read in the .csv file and have a quick look at the .csv.
```{r,}
phPINK <- read.csv(phPINKpath, header = TRUE)
head(phPINK) # have a look

#rename columns
colnames(phPINK) <- c("Sequence", "Start", "End", "Modification" , "X3", "X30", "X300")

length(unique(phPINK$Sequence)) # peptide sequences
```
repeat for other dataset
```{r,}
phPINKcomplex <- read.csv(phPINKcomplexpath, header = TRUE)
head(phPINKcomplex) # have a look

#rename columns
colnames(phPINKcomplex) <- c("Sequence", "Start", "End", "Modification" , "X3", "X30", "X300")

length(unique(phPINKcomplex$Sequence)) # peptide sequences
```
Let's us check that the sequences and modifications match.
```{r,}
all(phPINK$Modification == phPINKcomplex$Modification)
all(phPINK$Sequence == phPINKcomplex$Sequence)

```
Let's convert each of the datasets to long format
```{r,}
phPINK_long <- pivot_longer(data.frame(phPINK), col = 5:7, names_to = c("Exposure"), values_to = "Deuterium incoperation")
head(phPINK_long)
phPINKcomplex_long <- pivot_longer(data.frame(phPINKcomplex), col = 5:7, names_to = c("Exposure"), values_to = "Deuterium incoperation")
head(phPINKcomplex_long)
```
For each experiment add a state column
```{r,}
phPINK_long$state <- "phPINK"
phPINKcomplex_long$state <- "Nb696"
```

Now combine the datasets
```{r,}
phPINKdf <- bind_rows(phPINK_long, phPINKcomplex_long)
phPINKdf$Exposure <- rep(c(3, 30, 300), times = nrow(phPINKdf)/3)
colnames(phPINKdf)[6] <- "Uptake"
```


Let us have a quick visualisation of some the data so that we can see some of
the features

```{r,}
filter(phPINKdf, Sequence == unique(phPINKdf$Sequence)[2]) %>%
    ggplot(aes(x = Exposure, y = Uptake,
               color = factor(state)), group = factor(Modification)) + 
    theme_classic() + geom_point(size = 2) + 
    scale_color_manual(values = brewer.pal(n = 7, name = "Set2")) + 
    labs(color = "experiment", x = "Deuterium Exposure", y = "Deuterium incoperation")
```
We can see that the units of the time dimension are in seconds and that
Deuterium incoperation has been normalized into percentage incoperation.

# Parsing to an object of class QFeatures

Working from a .csv is likely to cause issues downstream. Indeed, we run
the risk of accidentally changing the data or corrupting the file in some way.
Secondly, all .csvs will be formatted slightly different and so making extensible
tools for these files will be inefficient. Furthermore, working with a generic
class used in other mass-spectrometry fields can speed up analysis and adoption
of new methods. We will work the class `QFeatures` from the `QFeatures` class
as it is a powerful and scalable way to store quantitative mass-spectrometry data.

Firstly, the data is storted in long format rather than wide format. We first 
switch the data to wide format. 
```{r,}
PINK_wide <- pivot_wider(data.frame(phPINKdf),
                        values_from = Uptake,
                        names_from = c("Exposure", "state"),
                        id_cols = c("Sequence", "Modification"))
head(PINK_wide)

```

We also note that the colnames are not very informative. We are going to format
in a very specific way so that later functions can automatically infer the design
from the column names. We provide in the format X(time)rep(replicate)cond(condition)
```{r,}
colnames(PINK_wide)[-c(1,2)]

new.colnames <- paste0("X", colnames(PINK_wide)[-c(1,2)])
new.colnames <- gsub("_", "rep1cond", new.colnames)

new.colnames
```
We will now parse the data into an object of class `QFeatures`, we have provided
a function to assist with this in the package. If you want to do this yourself
use the `readQFeatures` function from the `QFeatures` package. Here,
we must provide the modification as part of the rownaes else some of the
rows would be the same.
```{r,}
PINKqDF <- parseDeutData(object = DataFrame(PINK_wide),
                         rownames = paste0(PINK_wide$Sequence, ",", PINK_wide$Modification),
                         design = new.colnames,
                         quantcol = 3:8)

```

# Heatmap visualisations of HDX data

To help us get used to the `QFeatures` we show how to generate a heatmap
of these data from this object:

```{r, fig.height = 16, fig.width = 20, fig.align = "center"}
pheatmap(t(assay(PINKqDF)),
         cluster_rows = FALSE, 
         cluster_cols = FALSE,
         color = brewer.pal(n = 9, name = "BuPu"),
         main = "PINK1 deuterium incoperation heatmap", 
         fontsize = 14,
         legend_breaks = c(0, 5, 10, 15, 30, 40, 60, max(assay(PINKqDF))),
         legend_labels = c("0", "5", "10", "15", "30","40", "60", "Incorporation"))
```


# Functional data analysis of HDX-MS data of PINK1

The `hdxstats` package uses an empirical Bayes functional approach to analyse
the data. We explain this idea in steps so that we can get an idea of the approach.
First we fit the parametric model to the data. This will allow us to explore
the `HdxStatModel` class. 

```{r,}
res <- differentialUptakeKinetics(object = PINKqDF, #provide a QFeature object
                                  feature = rownames(PINKqDF)[[1]][3], # which peptide to do we fit
                                  start = list(a = NULL, b = 0.001),
                                  formula = value ~ a * (1 - exp(- b * timepoint)) + 30) # what are the starting parameter guesses
```
Here, we see the `HdxStatModel` class, and that a Functional Model was applied
to the data and a total of 2 models were fitted.
```{r,}
res
```
The `nullmodel` and `alternative` slots of an instance of `HdxStatModel` provide
the underlying fitted models. The `method` and `formula` slots provide vital 
information about what analysis was performed. The `vis` slot provides a `ggplot`
object so that we can visualise the functional fits.
```{r,}
res@vis
```
We then fit a simplified kinetic model, where only the plateau (recovery) and 
rate is inferred.

```{r,}
res_all <- fitUptakeKinetics(object = PINKqDF,
                             feature = rownames(PINKqDF)[[1]],
                             start = list(a = NULL, b = 0.001),
                             formula = value ~ a * (1 - exp(-b*(timepoint))) + 30)
  
funresPINK <- processFunctional(object = PINKqDF,
                                   params = res_all)
```


