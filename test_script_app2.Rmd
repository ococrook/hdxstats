---
title: "R Notebook"
output: html_notebook
---

# Load required libraries

```{r}
library("hdxstats")
library("dplyr")
library("ggplot2")
library("RColorBrewer")
library("tidyr")
library("pheatmap")
library("scales")
library("viridis")
library("patchwork")
library("Biostrings")
library("xfun")
library("tidyverse")
```

```{r}
source("R/test_script_app2.R")
```


# Parsing Raw Data

Parse input raw data and output `QFeatures` object instance given a CSV file path for different test cases.

```{r}
# First test case
csv_filepath <- "/homes/sanjuan/R/x86_64-pc-linux-gnu-library/4.1/hdxstats/extdata/MBP.csv"

# CASE 1: Parse data, given input data file path + parameter file
hdx_data <- extract_hdx_data(csv_filepath, parameter_file = "vignettes/data/myparameters.hdxp")

# CASE 2: Parse data, given input data file path + list of parameters
data <- read_csv(csv_filepath)
myparameters <- make_parameter_file(data)
hdx_data <- extract_hdx_data(csv_filepath, parameters = myparameters)

# CASE 3: Parse data, given input data file path. Work out parameters for pre-processing using interactive mode

```
```{r}
hdx_data <- extract_hdx_data(csv_filepath, parameter_file = "vignettes/data/myparameters.hdxp")
```


# Data Analysis of Deuterium Uptake Kinetics

## TEST 1:

### Perform Data Analysis: Plain fitting

* Deuterium-update fitting for all peptides
* Plain fitting - not comparing against a reference state or condition

```{r}
# INPUT
data_selection <- hdx_data[,1:24]
all_peptides <- rownames(data_selection)[[1]]
starting_parameters <- list(a = NULL, b = 0.001,  d = NULL, p = 1)
# OUTPUT
results <- analyse_kinetics(data = data_selection, 
                            method = "fit", 
                            peptide_selection = all_peptides, 
                            start = starting_parameters)
```

```{r}
results$method
```

### Visualise Output from Data Analysis

View fitting curves of Deu-uptake kinetics for all available conditions associated to selected peptides

```{r, fig.width= 22, fig.height = 7}
graphics_kinetics <- visualise_hdx_data(results, type="kinetics") 
graphics_kinetics[[1]] | graphics_kinetics[[2]] | graphics_kinetics[[3]]
```

View forest plots showing the difference between uptake measurements between conditions, plus the dispersion between their respective fitting model parameters

```{r, fig.width= 22, fig.height = 10}
graphics_forest <- visualise_hdx_data(results, type="forest")
graphics_forest[[1]] | graphics_forest[[2]] | graphics_forest[[3]]
```

Combine graphical outputs in a single canvas

```{r, fig.width= 22, fig.height = 10}
graphics_forest[[1]] | graphics_kinetic[[1]]
```
Display numerical values as a table 

```{r}
graphics_forest[[1]]$data
```

### Perform Data Analysis: Differential fitting

* Deuterium-update fitting for data selection 
* Differential fitting - with respect to a *single reference* peptide

```{r}
# INPUT 
data_selection <- hdx_data[,1:100]
all_peptides <- rownames(data_selection)[[1]] # get all peptides
starting_parameters <- list(a = NULL, b = 0.0001,  d = NULL, p = 1)

# OUTPUT
results <- analyse_kinetics(data = data_selection, 
                            method = "dfit", 
                            peptide_selection = all_peptides[37], 
                            start = starting_parameters)

```

```{r}
graphics_kinetics <- visualise_hdx_data(results, type="kinetics")
```

View graphical output for reference peptide shown in LHS Top corner. 

```{r}
graphics_kinetics
```

## TEST CASE 2

Single-domain antibody (sdAb) binding assays to HOIP.


```{r}
csv_filepath <- "/homes/sanjuan/R/x86_64-pc-linux-gnu-library/4.1/hdxstats/extdata/N64184_1a2_state.csv" 
```


```{r}
data <- read_csv(csv_filepath)
make_parameter_file(data, save = "vignettes/data/N64184_1a2_state.hdxp")
```


```{r}
hdx_data <- extract_hdx_data(csv_filepath, parameter_file = "vignettes/data/N64184_1a2_state.hdxp")
```


```{r}
# INPUT 
data_selection <- hdx_data[,1:33]
all_peptides <- rownames(data_selection)[[1]] # get all peptides
starting_parameters <- list(a = NULL, b = 0.01,  d = NULL)
formula = value ~ a * (1 - exp(-b*(timepoint))) + d

# OUTPUT
results <- analyse_kinetics(data = data_selection, 
                            method = "dfit", 
                            peptide_selection = all_peptides[3], 
                            start = starting_parameters,
                            formula = formula)
```


```{r}
graphics <- visualise_hdx_data(results, type="kinetics")

custom_colors <- scale_color_manual(values = colorRampPalette(brewer.pal(8, name = "Set2"))(11))
graphics + custom_colors
```


# TEST CASE 3

Original raw data
```{r}
#csv_filepath <- "inst/extdata/Project_2_SecA_Cluster_Data.csv"
#data <- read_csv(csv_filepath)
#data$Replicate <- unlist(lapply(strsplit(data$File, split="_"), function(x) tail(x, n=1)))
#write_csv(data, file = "inst/extdata/Project_2_SecA_Cluster_Data_edited.csv")

csv_filepath <- "inst/extdata/Project_2_SecA_Cluster_Data_edited.csv"
```

Had to pre-process its content to add Replicate column

```{r}
data <- read_csv(csv_filepath)
make_parameter_file(data, save = "vignettes/data/Project_2_SecA_Cluster_Data.hdxp")
```

```{r}
hdx_data <- extract_hdx_data(csv_filepath, parameter_file = "vignettes/data/Project_2_SecA_Cluster_Data.hdxp")
```


```{r, fig.height = 20, fig.width = 80, fig.align = "center"}
pheatmap(t(assay(hdx_data)),
         cluster_rows = FALSE, 
         cluster_cols = FALSE,
         color = brewer.pal(n = 9, name = "BuPu"),
         main = "secA heatmap", 
         fontsize = 14,
         legend_breaks = c(0, 1, 2, 3, 4, 5, 6, max(assay(hdx_data))),
         legend_labels = c("0", "1", "2", "3", "4", "5", "6", "Incorporation"))
```


```{r}
# Find out how many unique peptides and charge states exist
length(rownames(assay(hdx_data)))
# Extract all column values for a given peptide and charge state ( all states, all replicates, all timepoints)
peptide_charge <- "YESALKKANL_1" #"LGGTQ_1"
peptide_charge_data <- as.data.frame(assay(hdx_data))[peptide_charge, ]
peptide_charge_data <- longFormat(peptide_charge_data)
peptide_charge_data$condition <- as.factor(str_match(peptide_charge_data$colname, "cond\\s*(.*)")[, 2]) # Modify this for data analysis functions since they expect a numeric for replicates
peptide_charge_conditions <- unique(peptide_charge_data$condition)
# For a fixed confition
state <- "SecA"
ldf <- peptide_charge_data %>% subset(condition == state)
ldf$timepoint <- as.numeric(str_match(ldf$colname, "X\\s*(.*?)\\s*rep")[, 2])
ldf$replicates <- as.factor(str_match(ldf$colname, "rep\\s*(.*)\\s*cond")[, 2])
# Identify if number of replicates for 0 timepoint match for subsequent timepoints and report if not the case
#sum(ldf$timepoint == 0)
#length(unique(ldf$timepoint))
ldf$replicates <- unlist(lapply(strsplit(as.vector(as.factor(str_match(ldf$colname, "rep\\s*(.*)\\s*cond")[, 2])), split="_"), function(x) tail(x, n=1)))
# Subtract Deu uptake value at 0 timepoint
replicate_number <- 1
single_replicate_data <- ldf %>% subset(replicates == replicate_number)
x <- single_replicate_data %>% subset(timepoint == 0)
if (is.null(x$value) | is.na(x$value)){
  print("Found a NULL or NA vakue for timepoint 0")
  print(x)
}else{
single_replicate_data$value <- single_replicate_data$value - x$value
print(single_replicate_data)
}
```


```{r}
message <-paste("INFO: You have", length(rownames(assay(hdx_data))), "peptide-charge paired values")
print(message)
for (peptide_charge in rownames(assay(hdx_data))){
  peptide_charge_data <- as.data.frame(assay(hdx_data))[peptide_charge, ]
  peptide_charge_data <- longFormat(peptide_charge_data)
  peptide_charge_data$condition <- as.factor(str_match(peptide_charge_data$colname, "cond\\s*(.*)")[, 2])
  
  peptide_charge_conditions <- unique(peptide_charge_data$condition)
  message <- paste("INFO: For ", peptide_charge, ", you have", length(peptide_charge_conditions), "conditions")
  print(message)
  
  for (state in peptide_charge_conditions){
    ldf <- peptide_charge_data %>% subset(condition == state)
    ldf$timepoint <- as.numeric(str_match(ldf$colname, "X\\s*(.*?)\\s*rep")[, 2])
    ldf$replicates <- as.factor(str_match(ldf$colname, "rep\\s*(.*)\\s*cond")[, 2])
    
    ldf$replicates <- unlist(lapply(strsplit(as.vector(as.factor(str_match(ldf$colname, "rep\\s*(.*)\\s*cond")[, 2])), split="_"), function(x) tail(x, n=1)))
    # Subtract Deu uptake value at 0 timepoint
    message <- paste("INFO: You have", length(unique(ldf$replicates)), "replicates, for", state)
    print(message)
    
    for (n_replicate in unique(ldf$replicates)){
      single_replicate_data <- ldf %>% subset(replicates == n_replicate)
      x <- single_replicate_data %>% subset(timepoint == 0)
      
      if (is.null(x$value) | is.na(x$value)){
        print("Found a NULL or NA vakue for timepoint 0")
        print(x)
      }else{
        single_replicate_data$value <- single_replicate_data$value - x$value
        print(single_replicate_data)
      }
      if (any(single_replicate_data$value < 0) | any(is.na(single_replicate_data$value))){
        print("BEFORE")
        print(single_replicate_data)
        single_replicate_data$value <- single_replicate_data$value - x$value
        print("AFTER")
        print(single_replicate_data)
      }
    }
  }
}
```


```{r}
graphics <- visualise_hdx_data(results, type="kinetics") # READY
graphics <- visualise_hdx_data(results, type="forest") # READY

# NOTE: This only works to compare ONLY TWO distinct conditions, for the same timepoint, for all peptide fragments
# This needs to define a BASELINE state/condition and an ALTERNATE sate/condition
# NOTE: Data must be normalised by intercept 
graphics <- visualise_hdx_data(results, type="manhatten", reference = NULL)# <<<<--- NEXT

# NOTE: NOT SURE ??
graphics <- visualise_hdx_data(results, type="epitope", level="peptide", fasta = "my_fasta_path") # Return an EpitopeMap
graphics <- visualise_hdx_data(results, type="epitope", level="residue", fasta = "my_fasta_path") # Return heatmap
graphics <- visualise_hdx_data(results, type="epitope", level="residue", pdb="my_pdb_path") # Return heatmap projected onto PDB

graphics <- visualise_hdx_data(results, type="protection", level="peptide") # Return heatmap for peptide residue-number ranges
graphics <- visualise_hdx_data(results, type="protection", level="residue", fasta = "my_fasta_path") # Return heatmap
graphics <- visualise_hdx_data(results, type="protection", level="residue", pdb="my_pdb_path") # Return heatmap projected onto PDB

# GUI: Make GUI by assembling these building blocks

```

